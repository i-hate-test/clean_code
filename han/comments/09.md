## Chapter 09 단위 테스트
### TDD 법칙 세가지
다들 잘 지키고 계신가요?
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

경험 상, 테스트가 실패하는 상태에서 코드를 짠 적이 얼마 없던 것 같아요. \
테스트를 성공시켜야겠다는 생각을 하면서 일단 테스트 코드를 짜고,
실제 코드를 설계대로 수정하면서 테스트를 성공시켰던 경험이 많습니다. \
정말 필요한 기능만 만들기 위한 습관을 들이기 위해서 3번 규치을 잘지켜야겠습니다.

### 깨끗한 테스트 코드
```java
@Test
public void testGetPageHierarchyAsXml() throws Exception {
    makePages("PageOne", "PageOne.ChildOne", "PageTwo");

    submitRequest("root", "type:pages");

    assertResponseIsXML();
    assertResponseContains(
        "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
    );
}
```
1. 읽는 사람이 테스트 기능을 바로 이해할 수 있도록 **곧바로 본론**에 돌입하자. \
   기능을 테스트하기 위해 given, build 등의 상황을 준비하는 코드가 번잡해질 수 있다.
   또한 기능 수행의 결과를 단언하는 assert 문이 여러번 수행될 수 있다. \
   이런 코드를 하나의 테스트 메서드로 묶어서 테스트 코드의 의도를 명확히 드러내자.
2. 풍부한 표현력을 갖춘 테스트 코드가 되기 위해 **테스트 언어**를 사용하자. \
   makePages()와 같이 XML 관련 조작을 테스트하기 위한 빌딩을 하는 유틸리티 함수를 만들 수 있다.
   이는 XML이라는 도메인에 특화되어 있으며 동시에 테스트 API 내부에 선언된 유틸이다.
3. **이중 표준**(Double Standard)을 활용하자. \
   우리에게 익숙한 개념은 이중 잣대다.
   테스트 환경과 실제 환경의 표준이 다름을 이해한다면,
   테스트 환경에서 메모리 사용을 타이트하게 제어할 필요가 없다. 물론 테스트 속도가 중요할 순 있다. \
   네이밍 컨벤션도 실제 코드와 다르게 적용해도 좋다. 결국 깨끗한 테스트 코드의 본질은 읽기 편해야한다는 것이다.
```java
public class TestTemperatureConditioner {
    public static void turnOnHighTemperature() {
        assertEquals("HBchL", getState());
    }
}
```
### F.I.R.S.T
깨끗한 테스트 코드를 만들기 위한 5가지 규칙
1. **Fast**: 테스트는 빨라야 한다. 테스트가 느리면 자주 돌릴 엄두를 못내게 된다.
2. **Independent**: 테스트는 서로 의존하면 안된다. 테스트가 서로 의존하면, 한 테스트가 다른 테스트가 실패하게 만들 수 있다.
3. **Repeatable**: 테스트는 어떤 환경에서도 반복 가능해야 한다. 테스트가 환경에 의존하면, 환경이 변하면 테스트가 실패할 수 있다.
4. **Self-Validating**: 테스트는 자신이 스스로 성공 여부를 판단해야 한다. 로깅 -> 개발자 판단은 일어나면 안 된다.
5. **Timely**: 테스트는 적시에 작성해야 한다. 테스트를 먼저 작성하면, 테스트를 통과하는 코드를 작성하게 된다.
